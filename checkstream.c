/*
 * Copyright (c) 2004-2009 Silicon Graphics, Inc. All rights reserved.
 *         By Greg Banks <gnb@sgi.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
#include "common.h"
#include "stream.h"
#include "args.h"
#include "panic.h"

/*
 * Checks the stream of data generated by genstream for consistency.
 */

typedef enum
{
    FM_NONE,	    /* everything's cool */
    FM_SHORT,	    /* file too short */
    FM_ZERO,	    /* record is entirely zero */
    FM_BAD_CHECKSUM,/* failed checksum */
    FM_BAD_TAG,	    /* valid record, wrong tag */
    FM_BAD_OFFSET,  /* valid record, wrong offset */
    FM_BAD_CREATOR, /* valid record, wrong creator */
    FM_TOTAL,	    /* sum of above */
    FM_NUM
} failure_mode_t;

const char *argv0;
int verbose = 0;
bool_t stop_on_error = FALSE;
bool_t dump_on_error = FALSE;
uint8_t tag = 0x0;
bool_t tag_flag = FALSE;
bool_t creator_flag = FALSE;
static const char *failure_names[FM_NUM] =
{
    "valid data",
    "file short",
    "zero data",
    "bad checksum",
    "bad tag",
    "bad offset",
    "bad creator",
    "total"
};
static const char *failure_explanations[FM_NUM] =
{
    0,
    "less data was read than expected at offset %llu",
    "you may wish to check for file holes with xfs_bmap",
    "data is probably rubbish",
    "data is from a previous run or from another file tagged %lld",
    "data has been transposed within the file by %lld bytes",
    "data generated by genstream pid %u started at %s",
    0
};

/* statistics */
uint64_t	total_bytes;		/* bytes read */
uint64_t	corrupt_bytes[FM_NUM];	/* bytes corrupted, by failure mode */
uint32_t	num_errors[FM_NUM];	/* number of detected corrupt ranges */
uint64_t	start_us;		/* test start timeval as microseconds */

volatile int signalled = 0;

static void
handle_sig(int sig)
{
    signalled++;
}

static void
emit_separator(void)
{
    fprintf(stderr, "%s: ------------------------------------------------\n", argv0);
}

static void
handle_first_error(void)
{
    if (stop_on_error)
	exit(1);

    if (dump_on_error)
	panic();
}

static uint32_t
get_num_errors(void)
{
    failure_mode_t failure;
    uint32_t n = 0;

    for (failure = 0 ; failure < FM_TOTAL ; failure++)
    {
	if (failure != FM_NONE && failure != FM_TOTAL)
	    n += num_errors[failure];
    }

    return n;
}

static void
emit_stats(stream_t *s)
{
    failure_mode_t failure;
    uint64_t deltat = time_now() - start_us;
    char sizebuf1[32];
    char sizebuf2[32];

    if (deltat == 0)
	deltat = 1;		/* JIC, avoid divide by zero */
    for (failure = FM_NONE ; failure < FM_TOTAL ; failure++)
    {
	if (num_errors[failure] > 0)
	    fprintf(stderr, "%s: [%s] %u %s in %u.%06u seconds (%g err/sec)\n",
		    argv0,
		    failure_names[failure],
		    num_errors[failure],
		    (failure == FM_NONE ? "valid extents" : "errors"),
		    time_seconds(deltat), time_microseconds(deltat),
		    (double)num_errors[failure] / time_double(deltat));
	if (corrupt_bytes[failure] > 0)
	    fprintf(stderr, "%s: [%s] %llu/%llu bytes (%s/%s)\n",
		    argv0,
		    failure_names[failure],
		    (unsigned long long)corrupt_bytes[failure],
		    (unsigned long long)total_bytes,
		    iec_sizestr(corrupt_bytes[failure], sizebuf1, sizeof(sizebuf1)),
		    iec_sizestr(total_bytes, sizebuf2, sizeof(sizebuf2)));
    }
    /* used for determining how many blocks have been read or written */
    fprintf(stderr, "%s: read %llu blocks %llu bytes in %u.%06u seconds (%g KiB/sec)%s\n",
		argv0,
		(unsigned long long)s->stats.nblocks,
		(unsigned long long)s->stats.nbytes,
		time_seconds(deltat), time_microseconds(deltat),
		(double)s->stats.nbytes / time_double(deltat) / 1024.0,
		(get_num_errors() ? "" : ", no errors"));

    fflush(stderr); /* JIC */
}

static void
found_extent(uint64_t offset, uint64_t len,
	     failure_mode_t failure, uint64_t detail)
{
    if (!len)
	return;
    num_errors[failure]++;
    num_errors[FM_TOTAL]++;
    corrupt_bytes[failure] += len;
    corrupt_bytes[FM_TOTAL] += len;

    emit_separator();
    fprintf(stderr, "%s: %s for %llu bytes at offset %llu\n",
	    argv0, failure_names[failure],
	    (unsigned long long)len, (unsigned long long)offset);
    if (failure_explanations[failure])
    {
	fprintf(stderr, "%s: ", argv0);
	if (failure == FM_BAD_CREATOR)
	{
	    fprintf(stderr, failure_explanations[failure],
		    creator_get_pid(detail),
		    creator_to_timestamp_str(detail));
	}
	else
	    fprintf(stderr, failure_explanations[failure], detail);
	fprintf(stderr, "\n");
    }

}

static void
check_stream(stream_t *s, uint64_t length, uint64_t offset0)
{
    uint64_t i, off = offset0, fi, start = offset0;
    size_t record_size = (creator_flag ? RECORD_SIZE_CREATOR : RECORD_SIZE);
    uint64_t record_mask = (creator_flag ? RECORD_MASK_CREATOR : RECORD_MASK);
    uint16_t csum;
    failure_mode_t failure, last_failure = FM_NONE;
    uint64_t failure_detail, last_failure_detail = 0;
    record_t *rec;
    uint8_t ftag = 0;
    static const record_t zero_record;
    uint64_t creator, expected_creator = 0;

    if (start_us == 0)
	start_us = time_now();

    if (length < record_size)
    {
	fprintf(stderr, "%s: file too short: must be at least %u bytes long\n",
		argv0, (unsigned int)record_size);
	found_extent(0, length, FM_SHORT, 0);
	goto out;
    }
    /* has to be multiple of 8 bytes */
    if ((length & record_mask))
    {
	fprintf(stderr, "%s: warning: unaligned file length "
		        "(will not check last %d bytes)\n",
			argv0, (int)(length & record_mask));
	length &= ~record_mask;
    }

    for (i = 0 ; !signalled && i < length ; i += record_size)
    {
	off = i + offset0;

	if ((rec = (record_t *)stream_inline_read(s, record_size)) == 0)
	{
	    if (!signalled)
	    {
		fprintf(stderr, "%s: read failed at offset %llu\n",
	    	    	    argv0, (unsigned long long)off);
		found_extent(start, (off-start), last_failure, last_failure_detail);
		found_extent(off, record_size, FM_SHORT, off);
		last_failure = FM_SHORT;
	    }
	    break;
	}
	total_bytes += record_size;

	if (verbose > 3)
	    hexdump(off, rec, record_size);

	if (creator_flag)
	    csum = aligned_ip_checksum_8(&rec->w16[0]);
	else
	    csum = aligned_ip_checksum_4(&rec->w16[0]);

	if (tag_flag)
	{
	    fi = (uint64_t)ntohl(rec->w32[1]) | ((uint64_t)rec->w8[3] << 32);
	    ftag = rec->w8[2];
	}
	else
	{
	    fi = (uint64_t)ntohl(rec->w32[1]) | ((uint64_t)ntohs(rec->w16[1]) << 32);
	}
	if (creator_flag)
	{
	    creator = (uint64_t)ntohl(rec->w32[3]) | ((uint64_t)ntohl(rec->w32[2]) << 32);
	    if (!expected_creator)
	    {
		fprintf(stderr, "%s: file was generated by genstream pid %u started at %s\n",
				argv0,
				creator_get_pid(creator),
				creator_to_timestamp_str(creator));
		expected_creator = creator;
	    }
	}

	if (verbose > 2)
	    fprintf(stderr, "[0x%llx] offset 0x%llx tag %02x checksum %04x\n",
	    	    (unsigned long long)off, (unsigned long long)fi,
		    (unsigned)ftag, (unsigned)csum);

	failure = FM_NONE;
	failure_detail = 0;
	if (csum)
	{
	    /*
	     * Note, a zero record will fail the checksum, so we
	     * can delay checking for zero records until then.
	     */
	    if (!memcmp(rec, &zero_record, record_size))
	    {
		if (verbose > 1)
		    fprintf(stderr, "%s: record is zero at 0x%llx\n",
			    argv0, (unsigned long long)off);
		failure = FM_ZERO;
	    }
	    else
	    {
		if (verbose > 1)
		    fprintf(stderr, "%s: checksum failed at 0x%llx\n",
			    argv0, (unsigned long long)off);
		failure = FM_BAD_CHECKSUM;
	    }
	}
	else
	{
	    if (fi != off)
	    {
		if (verbose > 1)
		    fprintf(stderr, "%s: record at 0x%llx should be at 0x%llx\n",
			    argv0, (unsigned long long)off, (unsigned long long)fi);
		failure = FM_BAD_OFFSET;
		failure_detail = (off - fi);
	    }
	    if (tag_flag && ftag != tag)
	    {
		if (verbose > 1)
		    fprintf(stderr, "%s: record at 0x%llx should be tagged %u not %u\n",
			    argv0, (unsigned long long)off, (unsigned)tag, (unsigned)ftag);
		failure = FM_BAD_TAG;
		failure_detail = ftag;
	    }
	    if (creator_flag && creator != expected_creator)
	    {
		if (verbose > 1)
		    fprintf(stderr, "%s: record at 0x%llx should have creator 0x%llx not 0x%llx\n",
			    argv0, (unsigned long long)off,
			    (unsigned long long)expected_creator,
			    (unsigned long long)creator);
		failure = FM_BAD_CREATOR;
		failure_detail = creator;
	    }
	}

	if (failure && failure != FM_ZERO && verbose)
	    hexdump(off-record_size, rec, record_size);

	if (failure && !last_failure)
	{
	    /* start of range of bad records */
	    found_extent(start, (off-start), FM_NONE, 0);
	    start = off;
	    if (failure != FM_ZERO && verbose)
	    {
		emit_separator();
		fprintf(stderr, "%s: 0x%llx: hexdump of %s data\n",
			argv0, (unsigned long long)off, failure_names[failure]);
	    }
	}
	else if (!failure && last_failure)
	{
	    /* end of range of bad records */
	    found_extent(start, (off-start), last_failure, last_failure_detail);
	    emit_stats(s);
	    if (get_num_errors() == 1)
		handle_first_error();
	    start = off;
	}
	else if (failure &&
	         (failure != last_failure ||
		  failure_detail != last_failure_detail))
	{
	    /* transition between two failure modes */
	    found_extent(start, (off-start), last_failure, last_failure_detail);
	    emit_stats(s);
	    if (get_num_errors() == 1)
		handle_first_error();
	    start = off;
	    if (failure != FM_ZERO && verbose)
	    {
		emit_separator();
		fprintf(stderr, "%s: 0x%llx: hexdump of %s data\n",
			argv0, (unsigned long long)off, failure_names[failure]);
	    }
	}
	last_failure = failure;
	last_failure_detail = failure_detail;
    }

    if (last_failure != FM_SHORT)
	found_extent(start, (off+record_size-start), last_failure, last_failure_detail);

out:
    if (get_num_errors())
	fprintf(stderr, "%s: \n", argv0);
    emit_separator();
    fprintf(stderr, "%s: end of file summary\n", argv0);
    emit_stats(s);
    if (get_num_errors() == 1)
	handle_first_error();
}

static void
format_argv0(const char *filename)
{
    static char buf[256];

    if (tag_flag)
	snprintf(buf, sizeof(buf), "%s[tag%d]", argv0, tag);
    else if (filename != 0)
	snprintf(buf, sizeof(buf), "%s[%s]", argv0, tail(filename));
    else
	snprintf(buf, sizeof(buf), "%s[pid%d]", argv0, (int)getpid());
    argv0 = buf;
}

static const char usage_str[] =
"Usage: checkstream [options] --length=SIZE < file\n"
"       checkstream [options] [--loop] file\n"
"       checkstream [options] --seek=SIZE --length=SIZE file\n"
"       checkstream [options] --protocol=tcp\n"
"options:\n"
"    -v, --verbose              emit more messages (repeat for more messages)\n"
"    -l SIZE, --length=SIZE     check only the given length of data for filter mode\n"
"    -L, --loop                 check the data repeatedly\n"
"    -S, --sync                 open files with O_SYNC\n"
"    -D, --direct               open files with O_DIRECT\n"
"    -M, --mmap                 use mmap instead of the read() syscall\n"
"    -b SIZE, --blocksize=SIZE  block size for read() syscalls\n"
"    -e, --stop-on-error        exit on first detected error\n"
"    -s SIZE, --seek=SIZE       seek to the given offset before reading\n"
"    -o SIZE, --offset=SIZE     set expected offset of start of stream\n"
"    -T NUM, --tag=N            expect given 8-bit tag value in stream (default 0)\n"
"    --kernel-dump-on-error     trigger a kernel panic and dump on detecting an error\n"
"SIZE arguments may be specified as nnn[KMGT]\n"
;

static void
usage(void)
{
    fputs(usage_str, stderr);
    fflush(stderr);	/* JIC */
    exit(1);
}

static const args_desc_t arg_desc[] =
{
    {'v', "verbose",	    ARG_UNVALUED},
    {'l', "length",	    ARG_VALUED},
    {'L', "loop",	    ARG_UNVALUED},
    {'S', "sync",	    ARG_UNVALUED},
    {'D', "direct",	    ARG_UNVALUED},
    {'M', "mmap",	    ARG_UNVALUED},
    {'b', "blocksize",	    ARG_VALUED},
    {'e', "stop-on-error",  ARG_UNVALUED},
    {ARGS_NOSHORT(1), "kernel-dump-on-error", ARG_UNVALUED},
    {'s', "seek",   	    ARG_VALUED},
    {'o', "offset",   	    ARG_VALUED},
    {'C', "creator",	    ARG_UNVALUED},
    {'T', "tag",	    ARG_VALUED},
    {'P', "protocol",	    ARG_VALUED},
    {'p', "port",	    ARG_VALUED},
    {'V', "version",	    ARG_UNVALUED},
    {0, 0, 0}
};

int
main(int argc, char **argv)
{
    args_state_t as;
    uint64_t length;
    bool_t have_length = FALSE;
    bool_t filter_mode = FALSE;
    bool_t loop_mode = FALSE;
    bool_t mmap_flag = FALSE;
    int oflags = O_RDONLY;
    int xflags = 0;
    uint64_t bsize = 0;
    const char *file = 0;
    uint64_t seek = 0;
    bool_t have_seek = FALSE;
    uint64_t offset = 0;
    bool_t have_offset = FALSE;
    int c;
    int protocol = 0;
    uint16_t port = 0;
    stream_t *stream;

#ifdef O_LARGEFILE
    oflags |= O_LARGEFILE;
#endif

#if 0
    fprintf(stderr, "options {\n");
    args_init(&as, argc, argv, arg_desc);
    while ((c = args_next(&as)))
    {
	if (c < 0)
	    usage();
	fprintf(stderr, "    opt %c value=\"%s\"\n", c, args_value(&as));
    }
    fprintf(stderr, "} files {\n");
    for (c = 0 ; c < args_nfiles(&as) ; c++)
	fprintf(stderr, "    [%d]\"%s\"\n", c, args_files(&as)[c]);
    fprintf(stderr, "}\n");
    exit(0);
#endif

    argv0 = tail(argv[0]);
    args_init(&as, argc, argv, arg_desc);
    while ((c = args_next(&as)))
    {
	if (c < 0)
	    usage();

	switch (c)
	{
	case 'v':
	    verbose++;
	    break;

	case 'l':
	    if (have_length)
	    	usage();
	    if (!parse_length(args_value(&as), &length))
	    {
		fprintf(stderr, "%s: cannot parse length \"%s\"\n",
			    argv0, args_value(&as));
		exit(1);
	    }
	    have_length = TRUE;
	    break;

	case 'e':
	    stop_on_error = TRUE;
	    break;

	case ARGS_NOSHORT(1):
	    dump_on_error = TRUE;
	    if (!panic_enable())
		exit(1);
	    break;

	case 's':
	    if (!parse_length(args_value(&as), &seek))
	    {
		fprintf(stderr, "%s: cannot parse seek \"%s\"\n",
		    	argv0, args_value(&as));
		exit(1);
	    }
	    have_seek = TRUE;
	    break;

	case 'o':
	    if (!parse_length(args_value(&as), &offset))
	    {
		fprintf(stderr, "%s: cannot parse offset \"%s\"\n",
		    	argv0, args_value(&as));
		exit(1);
	    }
	    have_offset = TRUE;
	    break;

	case 'L':
	    loop_mode = TRUE;
	    break;

	case 'S':
	    oflags |= O_SYNC;
	    break;

        case 'D':
#ifdef O_DIRECT
	    oflags |= O_DIRECT;
#else
	    fprintf(stderr, "%s: O_DIRECT not implemented on this platform, failing\n",
	    	    argv0);
	    exit(1);
#endif /*O_DIRECT*/
	    break;

	case 'M':
	    mmap_flag = TRUE;
	    break;

	case 'b':
	    if (!parse_length(args_value(&as), &bsize))
	    {
		fprintf(stderr, "%s: cannot parse blocksize \"%s\"\n",
		    	argv0, args_value(&as));
		exit(1);
	    }
	    break;

	case 'T':
	    if (!parse_tag(args_value(&as), &tag))
	    {
		fprintf(stderr, "%s: cannot parse tag \"%s\"\n",
		    	argv0, args_value(&as));
		exit(1);
	    }
	    tag_flag = TRUE;
	    break;

	case 'C':
	    creator_flag = TRUE;
	    break;

	case 'P':
	    if (!parse_protocol(args_value(&as), &protocol))
		fatal("cannot parse protocol \"%s\"", args_value(&as));
	    break;

	case 'p':
	    if (!parse_tcp_port(args_value(&as), &port))
		fatal("cannot parse port \"%s\"", args_value(&as));
	    break;

	case 'V':
	    fputs("checkstream version " VERSION "\n", stdout);
	    fflush(stdout);
	    exit(0);
	}
    }

    if (args_nfiles(&as) > 1)
	usage();
    filter_mode = (args_nfiles(&as) == 0);
    file = (args_files(&as) == 0 ? 0 : args_files(&as)[0]);
    args_clear(&as);

    if (!filter_mode && file == 0)
	usage();
    if (filter_mode && loop_mode)
	usage();
    if (filter_mode && !have_length)
	usage();
    if (protocol && !have_length)
	usage();

    format_argv0(file);

    /* tell the user what the config is */
    if (verbose)
    {
	if (protocol)
	    printf("%s: reading %s from tcp port %d\n",
	    	    argv0, iec_sizestr(length, 0, 0), (int)port);
	else if (filter_mode)
	    printf("%s: reading %s from standard input\n",
	    	    argv0, iec_sizestr(length, 0, 0));
	else if (mmap_flag)
	    printf("%s: mmaping filename \"%s\"%s\n",
		argv0, file, (loop_mode ? " in loop" : ""));
	else
	{
	    printf("%s: reading filename \"%s\"%s\n",
		argv0, file, (loop_mode ? " in loop" : ""));
	    if (bsize)
		printf("%s: using blocksize %s\n",
	    		argv0, iec_sizestr(bsize, 0, 0));
	    if ((oflags & O_SYNC))
		printf("%s: using O_SYNC\n", argv0);
#ifdef O_DIRECT
	    if ((oflags & O_DIRECT))
		printf("%s: using O_DIRECT\n", argv0);
#endif /* O_DIRECT */
	}
	printf("%s: tag %d\n", argv0, tag);
    }


    signal(SIGINT, handle_sig);
    signal(SIGTERM, handle_sig);

    if (have_seek && !have_offset)
	offset = seek;

    if (protocol)
    {
	if (!port)
	    port = DEFAULT_PORT;
	stream = stream_server_open(protocol, port, xflags, bsize);
	if (stream == 0)
	    exit(1);	    /* error printed at lower level in stream.c */
	if (have_seek && stream_seek(stream, seek) < 0)
	    fatal("%s: failed to stream_seek", stream->name);
	check_stream(stream, length, offset);
    }
    else if (filter_mode)
    {
	stream = stream_unix_dopen(fileno(stdin), oflags, xflags, bsize);
	if (stream == 0)
	    exit(1);	    /* error printed at lower level in stream.c */
	if (have_seek && stream_seek(stream, seek) < 0)
	    fatal("%s: failed to stream_seek", stream->name);
	check_stream(stream, length, offset);
    }
    else
    {
	struct stat64 sb;

	do
	{
	    if (mmap_flag)
	    {
		if (stat64(file, &sb) < 0)
		{
		    perrorf("stat64(\"%s\")", file);
		    exit(1);
		}
		if ((stream = stream_mmap_open(file, oflags, xflags, sb.st_size)) == 0)
		    exit(1);	    /* error printed at lower level in stream.c */
	    }
	    else
	    {
		if ((stream = stream_unix_open(file, oflags, xflags, bsize)) == 0)
		    exit(1);	    /* error printed at lower level in stream.c */
		if (fstat64(stream->fd, &sb) < 0)
		{
		    perrorf("fstat64(\"%s\")", stream->name);
		    exit(1);
		}
	    }

	    if (have_seek && stream_seek(stream, seek) < 0)
		fatal("%s: failed to stream_seek", stream->name);
	    if (!have_length)
		length = sb.st_size - seek;
	    check_stream(stream, length, offset);
	    stream_close(stream);
	}
	while (loop_mode && !signalled);
    }

    if (get_num_errors())
    {
	emit_separator();
	fprintf(stderr, "%s: encountered %d errors, failing\n",
		argv0, get_num_errors());
    }

    return (get_num_errors() || signalled ? 1 : 0);
}

/* vim: set ts=8 sw=4 sts=4: */
